# 哈希表算法导论笔记与其c++实现（上）

本笔记是结合了算法导论第四版英文版22年的最新内容（11.5节中关于实际硬件的考量）与第三版中文版的经典算法内容，尝试浅谈哈希表背后的算法细节与数学理论分析，同时也是少有的一篇会实际兼顾哈希表的两种c++实现方式的文章，下面一起看看本篇笔记吧。

动态集合数据结构至少要支持Insert, Search和Delete这样的字典操作。例如，编译器都会维护一个字典（符号表），其中字典的关键字（key）为任意字符串，它与程序语言·中的标识符相对应。哈希表（Hash Table）是实现字典的一种有效数据结构，在实际应用中，其Search性能极好，其查找一个元素的期望时间为 $O(1)$ （最坏情形下，Search期望时间为  $O(n)$ ，与链表相同）。实际上，Python的内置字典的底层实现就是哈希表。

哈希表是普通数组的推广，普通数组通过直接寻址可以在 $O(1)$ 时间访问数组中的任意位置。11.1节就讨论直接寻址表与其c++实现。

当实际需求中要存储的关键字数目比全部的可能关键字总数要小很多时，采用哈希表来替代直接数组寻址会更有效，因为HashTable使用了一个长度与实际需求中要存储的关键字数目成比例的数组来存储（这里成比例指的是尺度相近，具体见11.2）。哈希表中的元素会根据关键字计算出相应的下标。11.2节就介绍哈希表的主要思想，着重介绍通过链接（chaining）方法解决冲突(collision)，并以该方式实现第一种哈希表。所谓冲突就是指多个关键字映射到同一个下标。11.3节介绍如何利用哈希函数来计算关键字对应的数组下标，还将介绍和分析散列技术的几种变形。11.4节介绍“开放寻址法”，这是另一种处理冲突的方法并基于此方法呈现哈希表的另一种实现方式。11.5节探讨了现代计算机系统的层级存储结构以及如何在这种系统下设计性能良好的哈希表，11.6节将探讨哈希表的应用。

本文章篇幅会非常长，所以会拆分上下两部分，第一部分包含11.1节到11.3节，第二部分包含11.4节到11.6节。

## 11.1直接寻址表



## 11.2哈希表

直接寻址表的缺点也很明显：

1.如果全域 $U$ 很大, 要存下大小为 $|U|$ 的一张表不太实际。

2，当实际需求中要存储的关键集合 $K$ 比全域 $U$ 要小很多时，直接寻址表里的绝大部分空间都被浪费了。

当实际需求中要存储的关键集合 $K$ 比全域 $U$ 要小很多时，散列表需要的存储空间比直接寻址表小很多，其空间大小仅为 $\Theta(|K|)$ , 同时Search操作期望用时依然只有 $O(1)$  （最坏情形下，Search期望时间为  $O(n)$ ，与链表相同， 比直接寻址表要差）。

不同于直接寻址中把关键字k 的元素放在slot k 中，哈希表中，该元素存放在槽 $h(k)$ 中，即利用哈希函数(hash function) h, 由关键字k计算出slot的位置h(k), h(k)即是k的哈希值。这里 函数h将关键的全域 $U$ 映射到散列表 $T[0..m-1]$ 的槽位上：

$$h:U\rightarrow\left\{0,1,...,m-1\right\}$$

这里哈希表的大小m一般要比 $|U|$ 小很多，从而节省了大量存储空间。下图描述了这个基本方法。

这里存在一个问题：两个关键字可能映射到同一个下标上，即同一个slot中。我们称这个情形为冲突(Collision)。幸运的是，我们能找到一些有效的思路来解决冲突。

思路1：理想的解决办法是避免所有的冲突。我们可以试图选择一个合适的哈希函数h来尽量做到这点，让h尽可能的随机，从而让冲突发生的可能性最小化，11.3节就是交代合适的哈希函数。

思路2：当出现冲突时，我们最直观的冲突解决方法称为链接法(chaining)，本节余下部分介绍这一方法。11.4节介绍另一种冲突解决方法，开放寻址法（open addressing）。

思路1与思路2一起使用，效果更佳。

### 通过链接法解决冲突



## 11.3哈希函数



## 11.4开放寻址法（Open Addressing）



## 11.5现实考量



## 11.6哈希表的应用